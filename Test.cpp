#include<bits/stdc++.h>
#define ll long long int
#define LL long long int
#define ULL unsigned long long int
#define sf(a) scanf("%d",&a)
#define sl(a) scanf("%lld",&a)
#define fr first
#define sc second
#define pii pair<int,int>
#define pll pair<LL,LL>
#define vi vector<int>
#define vll vector<LL>
#define vpii  vector<pii>
#define rep1(a,b) for(int a=1;a<=b;a++)
#define rep2(a,b) for(int a=0;a<b;a++)
#define CLR(a,b) memset(a,b,sizeof(a))
#define Clear(a,b) memset(a,b,sizeof(a))
#define pb push_back
#define mp make_pair
#define mod 1000000007
#define  LSOne(S) (S & (-S))
#define all(a) a.begin(),a.end()
#define Prime 31
using namespace std;
#define maxn 200100
#define INF 1<<29
#define inf 1ll<<62
#define mMax 20005
#define nMax 2505
#define SZ(a) a.size()
#define  Unique(A) (A.resize(distance(A.begin(),unique(all(A)))))
void printVector(vi a) {for(int ii=0;ii<SZ(a);ii++) cout<<a[ii]<<endl;}
ll _sieve_size;
bitset<1000000> bs;
vi primes;

void sieve(ll upperbound=1000000) {
  _sieve_size = upperbound + 1;
  bs.set();
  bs[0] = bs[1] = 0;
  for (ll i = 2; i <= _sieve_size; i++) if (bs[i]) {
    for (ll j = i * i; j <= _sieve_size; j += i) bs[j] = 0;
    primes.push_back((int)i);  // also add this vector containing list of primes
} }

bool isPrime(ll N) {
  if (N <= _sieve_size) return bs[N];
  for (int i = 0; i < (int)primes.size(); i++)
    if (N % primes[i] == 0) return false;
  return true;
}                      // note: only work for N <= (last prime in vi "primes")^2


// second part

vi primeFactors(ll N) {   // remember: vi is vector of integers, ll is long long
  vi factors;                    // vi `primes' (generated by sieve) is optional
  ll PF_idx = 0, PF = primes[PF_idx];     // using PF = 2, 3, 4, ..., is also ok
  while (N != 1 && (PF * PF <= N)) {   // stop at sqrt(N), but N can get smaller
    while (N % PF == 0) { N /= PF; factors.push_back(PF); }    // remove this PF
    PF = primes[++PF_idx];                              // only consider primes!
  }
  if (N != 1) factors.push_back(N);     // special case if N is actually a prime
  return factors;         // if pf exceeds 32-bit integer, you have to change vi
}

/// LeftEle= no of element int left side
/// left side has element from 1 to leftEle
/// right side has element from leftEle+1 to rightEle+leftEle
/// we have to add edge with respect to this indexing
/// by mapping them or something else
int N,M,L[2200],R[2200],dist[2200],leftEle,rightEle;
vector<vi>E;
bool BFS()
{
    queue<int>Q;
    for(int i=1; i<=leftEle; i++)
    {
        if(!L[i])
        {
            dist[i] = 0;
            Q.push(i);
        }
        else dist[i] = INF;
    }
    dist[0] = INF;
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        if(!u) continue;
        for(int i=0; i<SZ(E[u]); i++)
        {
            int v = E[u][i];
            if(dist[R[v]] == INF)
            {
                dist[R[v]] = dist[u]+1;
                Q.push(R[v]);
            }
        }
    }
    return (dist[0]!=INF);
}
bool dfs(int u)
{
    if(u==0) return true;
    for(int i=0; i<SZ(E[u]); i++)
    {
        int v = E[u][i];
        if(dist[u]+1 == dist[R[v]] &&dfs(R[v]))
        {
            L[u] = v;
            R[v] = u;
            return true;
        }
    }
    dist[u] = INF;
    return false;
}
int HopCraft()
{
    Clear(L,0);
    Clear(R,0);
    int ret = 0;
    while(BFS())
    {
        for(int i=1; i<=leftEle; i++)
            if(!L[i] &&dfs(i))
                ret++;
    }
    return ret;
}
void add(int u,int v)
{
    E[u].push_back(v);
    E[v].push_back(u);
}
int n,m;
struct node{
    int index;
    int value;
    node(){}
    node(int a,int b){
        index=a;
        value=b;
    }
} NodeList[2][2000];
struct boundary{
    int start;
    int end;
    boundary(){}
    boundary(int a,int b){
        start=a;
        end=b;
    }
} NodesBoundary[110];
LL arr[102];
int main()
{
    sieve();
    scanf("%d %d",&n,&m);
    rep1(i,n) scanf("%lld",&arr[i]);
    int B[3];
    B[0]=B[1]=1;
    int N = 50*32;
    rep1(i,n) {
        vi pF = primeFactors(arr[i]);
        NodesBoundary[i].start=B[i&1];
        rep2(j,SZ(pF)){
            NodeList[i&1][B[i&1]] = node(B[i&1]+((i&1)?0:N),pF[j]);
            B[i&1]++;
        }
        NodesBoundary[i].end=B[i&1]-1;
    }
    E.assign( 2*N  +2,vi());
    int a,b;
    leftEle=N;
    rightEle=N;
    for(int i=0;i<m;i++)
    {
        scanf("%d %d",&a,&b);
        for(int p=NodesBoundary[a].start;p<=NodesBoundary[a].end;p++)
            for(int q=NodesBoundary[b].start;q<=NodesBoundary[b].end;q++)
            {
                node one=NodeList[a&1][p],another=NodeList[b&1][q];
                if(one.value != another.value) continue;
                cout<<one.index<<" "<<another.index<<endl;
                add(one.index,another.index);
            }
    }
    int ans=HopCraft();
    printf("%d\n",ans);
    return 0;
}
